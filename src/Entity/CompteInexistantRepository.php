<?php

namespace App\Entity;

use Doctrine\ORM\EntityRepository;

/**
 * CompteInexistantRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class CompteInexistantRepository extends EntityRepository {

    /**
     * @var
     * Les variables
     * 
     * $param: contient en tableau la liste des paramètres
     * $query: instance de l'objet requête de doctrine
     * 
     * @param <string> $locale pour la gestion multilingue
     * @param <int> $idfile :Identifiant du fichier envoyé
     * @param <int> $total : Nbre total de fichier envoyés
     * @param <int> $page : Numero de page en cours
     * @param <int> $articles_per_page
     * @return  un tableau des comptes inexistants 
     */
    public function getCptesInexistants($locale, $idfile, $total, $page, $articles_per_page) {

        $param = array();

        $sql = 'SELECT c.id , c.compte , t.libTypeCompte ,t.id as typeid,c.dateNotification
              FROM   utbClientBundle:CompteInexistant c 
              INNER JOIN c.typeCompte t ';

        ($idfile == 0) ? $sql.='' : $sql.=' WHERE  c.idfile = :file ';

        if ($idfile != 0) {
            $param['file'] = $idfile;
        }

        $query = $this->_em->createQuery($sql);
        ($idfile == 0) ? $sql .='' : $query->setParameters($param);

        $query->setFirstResult(($page * $articles_per_page) - $articles_per_page);
        $query->setMaxResults($articles_per_page);

        return $query->getResult();
    }

    /**
     * 
     * @param <string> $locale pour la gestion multilingue
     * @param <int> $idfile :Identifiant du fichier envoyé
     * 
     * 
     * @return un nombre total de compte inexistant type entier
     */
    public function getTotalCompteInexistant($locale, $idfile) {

        $param = array();

        $sql = 'SELECT c.id , c.compte , t.libTypeCompte ,t.id as typeid,c.dateNotification
              FROM   utbClientBundle:CompteInexistant c 
              INNER JOIN c.typeCompte t ';

        ($idfile == 0) ? $sql.='' : $sql.=' WHERE  c.idfile = :file ';
        $sql.=' ORDER BY  t.id ';

        if ($idfile != 0) {
            $param['file'] = $type;
        }

        $query = $this->_em->createQuery($sql);
        ($idfile == 0) ? $sql .='' : $query->setParameters($param);

        return count($query->getResult());
    }

    /* public function getStatChargement($locale ,$type)
      {

      $param = array();

      $sql='SELECT c.id , t.libTypeCompte ,t.id as typeid
      FROM   utbClientBundle:Chargement c
      INNER JOIN c.typeCompte t ';

      ($type == 0)?  $sql.='' : $sql.=' WHERE  t.id = :type ' ;
      $sql.=' ORDER BY  t.id ' ;

      if ($type != 0) {
      $param['type']=$type;
      }

      $query = $this->_em->createQuery($sql);
      ($type != 0)? $sql .='' : $query->setParameters($param);

      $listetype = $query->getResult();

      foreach ($listetype as $value) {
      // nbre comptes du fichier
      $q2 = null;
      $q2 = $this->_em->createQuery('SELECT count(h.dateDeb)
      FROM utbClientBundle:HistoriqueConnexion h
      INNER JOIN abonne a
      WHERE  a.id = :abonne');

      $q2->setParameters(array('abonne'=>$article));

      $q2->setHint(
      \Doctrine\ORM\Query::HINT_CUSTOM_OUTPUT_WALKER, 'Gedmo\\Translatable\\Query\\TreeWalker\\TranslationWalker'
      );
      // Force the locale
      $q2->setHint(
      \Gedmo\Translatable\TranslatableListener::HINT_TRANSLATABLE_LOCALE, $locale
      );

      try {
      $lavaleur = $q2->getSingleScalarResult();
      } catch (\Doctrine\ORM\NoResultException $e) {
      $lavaleur = 0;
      }

      $resultat[] =  array(
      'num'=>$data['valeur'],
      'libelle'=>$data['libStat'],
      'valeur'=>$lavaleur,
      'ecart'=>$data['ecart']
      );


      }
      } */
}
